! This Source Code Form is subject to the terms of the Mozilla Public
! License, v. 2.0. If a copy of the MPL was not distributed with this
! file, You can obtain one at http://mozilla.org/MPL/2.0/.
!
!> Generic implementation of a data container.
!!
!! This module provides a container type that may contain all the relevant data
!! produced by a calculation. The container will store the data via parallel
!! IO routines in a file to allow easy access to its contents when restarting
!! or if the data needs to be deallocated to save memory.
!!
!! The specific container for a program should be generated by the separate
!! python script, which will generate a inherited type and implement the generic
!! routines provided in this module
!
MODULE container_interface

  IMPLICIT NONE

  INCLUDE 'mpif.h'
  EXTERNAL MPI_FILE_READ, MPI_FILE_READ_ALL

  PRIVATE
  PUBLIC no_error, file_not_open_error, out_of_bounds_error, &
    generic_routine_called_error, dimension_change_error, dimension_not_set_error, &
    dp, configuration, element_type, container_type, internal_config

  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15, 307)

  INTEGER, PARAMETER :: no_error = 0
  INTEGER, PARAMETER :: file_not_open_error = 1
  INTEGER, PARAMETER :: out_of_bounds_error = 2
  INTEGER, PARAMETER :: generic_routine_called_error = 3
  INTEGER, PARAMETER :: dimension_change_error = 4
  INTEGER, PARAMETER :: dimension_not_set_error = 5

  INTEGER, PARAMETER :: next_free = 1
  INTEGER(KIND=MPI_OFFSET_KIND), PARAMETER :: not_set = 0
  INTEGER(KIND=MPI_OFFSET_KIND), PARAMETER :: offset_position = 0

  !> Configuration passed to MPI_FILE_OPEN
  TYPE configuration
    INTEGER :: communicator = MPI_COMM_WORLD
    INTEGER :: mode = MPI_MODE_CREATE + MPI_MODE_RDWR
    CHARACTER(LEN=:), ALLOCATABLE :: filename
  END TYPE configuration

  !> When reading only a fraction of a particular array, use this type to specify which.
  TYPE element_type
    !> Element of which variable is accessed.
    INTEGER variable
    !> Specify which element is accessed.
    INTEGER access_index
  END TYPE element_type

  !> Generic implementation of the container class.
  !!
  !! Typically you will read and write the data with the routines provided by
  !! this generic type and the access the specific variables for your calculation.
  !! The routines without documentation are used internally to process the main
  !! call and should usually not be called by a user.
  TYPE container_type
    LOGICAL :: valid = .FALSE.
    INTEGER filehandle
    INTEGER(KIND=MPI_OFFSET_KIND), ALLOCATABLE :: offset(:)
    INTEGER, ALLOCATABLE :: num_dim(:)
  CONTAINS
    PROCEDURE :: open
    PROCEDURE :: close
    PROCEDURE :: write
    PROCEDURE :: write_variable
    PROCEDURE :: write_element
    PROCEDURE :: write_dimension
    PROCEDURE :: read
    PROCEDURE :: read_all
    PROCEDURE :: read_variable
    PROCEDURE :: read_all_variable
    PROCEDURE :: read_element
    PROCEDURE :: read_dimension
    PROCEDURE :: num_variable
    PROCEDURE :: check
    PROCEDURE :: check_dimension
    PROCEDURE :: check_config
    PROCEDURE :: seek_offset
    PROCEDURE :: update_offset
    PROCEDURE :: increase_offset
    PROCEDURE :: internal_init => generic_init
    PROCEDURE :: internal_read_variable => generic_read_variable
    PROCEDURE :: internal_read_element => generic_read_element
    PROCEDURE :: internal_write_variable => generic_write_variable
    PROCEDURE :: internal_write_element => generic_write_element
    PROCEDURE :: internal_update_offset => generic_update_offset
  END TYPE container_type

  TYPE internal_config
    INTEGER variable
    INTEGER access_index
    INTEGER, ALLOCATABLE :: dimension(:)
  END TYPE internal_config

CONTAINS

  !> Open a file associated with the container.
  SUBROUTINE open(container, config, ierr)
    !
    CLASS(container_type), INTENT(OUT) :: container
    TYPE(configuration), INTENT(IN) :: config
    INTEGER, INTENT(OUT) :: ierr
    INTEGER size_offset
    !
    CALL container%internal_init()
    !
    CALL MPI_TYPE_SIZE(MPI_OFFSET, size_offset, ierr)
    IF (ierr /= no_error) RETURN
    ALLOCATE(container%offset(container%num_variable() + 1))
    container%offset = not_set
    container%offset(next_free) = SIZE(container%offset) * size_offset
    !
    CALL MPI_FILE_OPEN(config%communicator, config%filename, config%mode, &
      MPI_INFO_NULL, container%filehandle, ierr)
    container%valid = (ierr == no_error)
    !
  END SUBROUTINE open

  !> Close the file associated with a container.
  SUBROUTINE close(container, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(OUT) :: ierr
    !
    DEALLOCATE(container%offset)
    CALL MPI_FILE_CLOSE(container%filehandle, ierr)
    container%valid = .FALSE.
    !
  END SUBROUTINE close

  !> Write all variables in the container to the associated file.
  SUBROUTINE write(container, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(OUT) :: ierr
    INTEGER ivar
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    DO ivar = 2, SIZE(container%offset)
      CALL container%write_variable(ivar, ierr)
      IF (ierr /= no_error) RETURN
    END DO
    !
  END SUBROUTINE write

  !> Write one specific variable of the container to the associated file.
  SUBROUTINE write_variable(container, variable, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    config%variable = variable
    CALL container%read_dimension(config%variable, config%dimension, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%internal_write_variable(config, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%update_offset(ierr)
    !
  END SUBROUTINE write_variable

  !> Write one element of one variable of the container to the associated file.
  SUBROUTINE write_element(container, element, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    TYPE(element_type), INTENT(IN) :: element
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    config%variable = element%variable
    config%access_index = element%access_index
    CALL container%read_dimension(config%variable, config%dimension, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%check_config(config, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%internal_write_element(config, ierr)
    !
  END SUBROUTINE write_element

  !> Write the array dimensions of one specified variable.
  SUBROUTINE write_dimension(container, variable, dimension, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable, dimension(:)
    INTEGER, INTENT(OUT) :: ierr
    INTEGER, ALLOCATABLE :: dims(:)
    !
    CALL container%seek_offset(variable, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%read_dimension(variable, dims, ierr)
    IF (ierr /= no_error) RETURN
    IF (ALLOCATED(dims)) THEN
      CALL container%check_dimension(dimension, dims, ierr)
    ELSE
      CALL MPI_FILE_WRITE(container%filehandle, dimension, SIZE(dimension), &
        MPI_INTEGER, MPI_STATUS_IGNORE, ierr)
    END IF
    IF (ierr /= no_error) RETURN
    CALL container%internal_update_offset(variable, dimension, ierr)
    !
  END SUBROUTINE write_dimension

  !> Read all variables in the container from the associated file.
  SUBROUTINE read(container, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    INTEGER ivar
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    DO ivar = 2, SIZE(container%offset)
      config%variable = ivar
      CALL container%read_dimension(config%variable, config%dimension, ierr)
      IF (ierr /= no_error) RETURN
      CALL container%internal_read_variable(MPI_FILE_READ, config, ierr)
      IF (ierr /= no_error) RETURN
    END DO
    !
  END SUBROUTINE read

  !> Read all variables in the container from the associated file with all CPU.
  SUBROUTINE read_all(container, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    INTEGER ivar
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    DO ivar = 2, SIZE(container%offset)
      config%variable = ivar
      CALL container%read_dimension(config%variable, config%dimension, ierr)
      IF (ierr /= no_error) RETURN
      CALL container%internal_read_variable(MPI_FILE_READ_ALL, config, ierr)
      IF (ierr /= no_error) RETURN
    END DO
    !
  END SUBROUTINE read_all

  !> Read one variable in the container from the associated file.
  SUBROUTINE read_variable(container, variable, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    config%variable = variable
    CALL container%read_dimension(config%variable, config%dimension, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%internal_read_variable(MPI_FILE_READ, config, ierr)
    !
  END SUBROUTINE read_variable

  !> Read one variable in the container from the associated file with all CPU.
  SUBROUTINE read_all_variable(container, variable, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    config%variable = variable
    CALL container%read_dimension(config%variable, config%dimension, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%internal_read_variable(MPI_FILE_READ_ALL, config, ierr)
    !
  END SUBROUTINE read_all_variable

  !> Read one element of one variable in the container from the associated file.
  SUBROUTINE read_element(container, element, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    TYPE(element_type), INTENT(IN) :: element
    INTEGER, INTENT(OUT) :: ierr
    TYPE(internal_config) config
    !
    CALL container%check(ierr)
    IF (ierr /= no_error) RETURN
    config%variable = element%variable
    config%access_index = element%access_index
    CALL container%read_dimension(config%variable, config%dimension, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%check_config(config, ierr)
    IF (ierr /= no_error) RETURN
    CALL container%internal_read_element(MPI_FILE_READ, config, ierr)
    !
  END SUBROUTINE read_element

  !> Read the array dimensions of one specified variable
  !!
  !! If variable is not written, will not allocate dimension.
  SUBROUTINE read_dimension(container, variable, dimension, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable
    INTEGER, INTENT(OUT), ALLOCATABLE :: dimension(:)
    INTEGER, INTENT(OUT) :: ierr
    !
    CALL container%seek_offset(variable, ierr)
    IF (ierr /= no_error) RETURN
    IF (container%offset(variable) == container%offset(next_free)) RETURN
    ALLOCATE(dimension(container%num_dim(variable)))
    CALL MPI_FILE_READ(container%filehandle, dimension, SIZE(dimension), &
      MPI_INTEGER, MPI_STATUS_IGNORE, ierr)
    !
  END SUBROUTINE read_dimension

  PURE INTEGER FUNCTION num_variable(container)
    !
    CLASS(container_type), INTENT(IN) :: container
    num_variable = SIZE(container%num_dim) - 1
    !
  END FUNCTION num_variable

  SUBROUTINE check(container, ierr)
    !
    CLASS(container_type), INTENT(IN) :: container
    INTEGER, INTENT(OUT) :: ierr
    !
    IF (container%valid) THEN
      ierr = no_error
    ELSE
      ierr = file_not_open_error
    END IF
    !
  END SUBROUTINE check

  SUBROUTINE check_dimension(container, reference, test, ierr)
    !
    CLASS(container_type), INTENT(IN) :: container
    INTEGER, INTENT(IN) :: reference(:), test(:)
    INTEGER, INTENT(OUT) :: ierr
    !
    ierr = dimension_change_error
    IF (SIZE(reference) == SIZE(test)) THEN
      IF (ALL(reference == test)) THEN
        ierr = no_error
      END IF
    END IF
    !
  END SUBROUTINE check_dimension

  SUBROUTINE check_config(container, config, ierr)
    !
    CLASS(container_type), INTENT(IN) :: container
    TYPE(internal_config), INTENT(IN) :: config
    INTEGER, INTENT(OUT) :: ierr
    !
    IF (.NOT.ALLOCATED(config%dimension)) THEN
      ierr = dimension_not_set_error
    ELSE IF (config%access_index <= 0 .OR. &
             config%access_index > config%dimension(SIZE(config%dimension))) THEN
      ierr = out_of_bounds_error
    ELSE
      ierr = no_error
    END IF
    !
  END SUBROUTINE check_config

  SUBROUTINE seek_offset(container, variable, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable
    INTEGER, INTENT(OUT) :: ierr
    INTEGER(KIND=MPI_OFFSET_KIND) filesize
    !
    IF (container%offset(variable) == not_set) THEN
      CALL MPI_FILE_READ_AT(container%filehandle, offset_position, container%offset, &
        SIZE(container%offset), MPI_OFFSET, MPI_STATUS_IGNORE, ierr)
      IF (ierr /= no_error) RETURN
      IF (container%offset(variable) == not_set) THEN
        container%offset(variable) = container%offset(next_free)
      END IF
    END IF
    CALL MPI_FILE_SEEK(container%filehandle, container%offset(variable), MPI_SEEK_SET, ierr)
    !
  END SUBROUTINE seek_offset

  SUBROUTINE update_offset(container, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(OUT) :: ierr
    INTEGER(KIND=MPI_OFFSET_KIND) current_position
    !
    CALL MPI_FILE_GET_POSITION(container%filehandle, current_position, ierr)
    IF (ierr /= no_error) RETURN
    container%offset(next_free) = MAX(container%offset(next_free), current_position)
    CALL MPI_FILE_WRITE_AT(container%filehandle, offset_position, container%offset, &
      SIZE(container%offset), MPI_OFFSET, MPI_STATUS_IGNORE, ierr)
    !
  END SUBROUTINE update_offset

  SUBROUTINE increase_offset(container, dims, datatype, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: dims(:), datatype
    INTEGER, INTENT(OUT) :: ierr
    INTEGER(KIND=MPI_OFFSET_KIND) :: offset
    INTEGER size_datatype
    !
    CALL MPI_TYPE_SIZE(datatype, size_datatype, ierr)
    IF (ierr /= no_error) RETURN
    offset = size_datatype * PRODUCT(INT(dims, KIND=MPI_OFFSET_KIND))
    CALL MPI_FILE_SEEK(container%filehandle, offset, MPI_SEEK_CUR, ierr)
    !
  END SUBROUTINE increase_offset

  SUBROUTINE generic_init(container)
    !
    CLASS(container_type), INTENT(OUT) :: container
    ALLOCATE(container%num_dim(0))
    !
  END SUBROUTINE generic_init

  SUBROUTINE generic_write_variable(container, config, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    TYPE(internal_config), INTENT(IN) :: config
    INTEGER, INTENT(OUT) :: ierr
    !
    ! specific implementation provided by derived class
    ierr = generic_routine_called_error
    !
  END SUBROUTINE generic_write_variable

  SUBROUTINE generic_write_element(container, config, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    TYPE(internal_config), INTENT(IN) :: config
    INTEGER, INTENT(OUT) :: ierr
    !
    ! specific implementation provided by derived class
    ierr = generic_routine_called_error
    !
  END SUBROUTINE generic_write_element

  SUBROUTINE generic_read_variable(container, mpi_func, config, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    EXTERNAL mpi_func
    TYPE(internal_config), INTENT(IN) :: config
    INTEGER, INTENT(OUT) :: ierr
    !
    ! specific implementation provided by derived class
    ierr = generic_routine_called_error
    !
  END SUBROUTINE generic_read_variable

  SUBROUTINE generic_read_element(container, mpi_func, config, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    EXTERNAL mpi_func
    TYPE(internal_config), INTENT(IN) :: config
    INTEGER, INTENT(OUT) :: ierr
    !
    ! specific implementation provided by derived class
    ierr = generic_routine_called_error
    !
  END SUBROUTINE generic_read_element

  SUBROUTINE generic_update_offset(container, variable, dimension, ierr)
    !
    CLASS(container_type), INTENT(INOUT) :: container
    INTEGER, INTENT(IN) :: variable, dimension(:)
    INTEGER, INTENT(OUT) :: ierr
    !
    ! specific implementation provided by derived class
    ierr = generic_routine_called_error
    !
  END SUBROUTINE generic_update_offset

END MODULE container_interface
